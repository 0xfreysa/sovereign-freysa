// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: key_pool.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "key_pool";

/** / Keys with predefined semantics. */
export enum BuiltinSigningKey {
  /** BUILTIN_SIGNING_KEY_UNSPECIFIED - Use default for method. */
  BUILTIN_SIGNING_KEY_UNSPECIFIED = 0,
  /** BUILTIN_SIGNING_KEY_ETHEREUM - Use key dedicated to Ethereum signing. */
  BUILTIN_SIGNING_KEY_ETHEREUM = 1,
  /** BUILTIN_SIGNING_KEY_SERVICE_RESPONSE - Use key dedicated to signing service responses (e.g., LLM responses). */
  BUILTIN_SIGNING_KEY_SERVICE_RESPONSE = 2,
  UNRECOGNIZED = -1,
}

export function builtinSigningKeyFromJSON(object: any): BuiltinSigningKey {
  switch (object) {
    case 0:
    case "BUILTIN_SIGNING_KEY_UNSPECIFIED":
      return BuiltinSigningKey.BUILTIN_SIGNING_KEY_UNSPECIFIED;
    case 1:
    case "BUILTIN_SIGNING_KEY_ETHEREUM":
      return BuiltinSigningKey.BUILTIN_SIGNING_KEY_ETHEREUM;
    case 2:
    case "BUILTIN_SIGNING_KEY_SERVICE_RESPONSE":
      return BuiltinSigningKey.BUILTIN_SIGNING_KEY_SERVICE_RESPONSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BuiltinSigningKey.UNRECOGNIZED;
  }
}

export function builtinSigningKeyToJSON(object: BuiltinSigningKey): string {
  switch (object) {
    case BuiltinSigningKey.BUILTIN_SIGNING_KEY_UNSPECIFIED:
      return "BUILTIN_SIGNING_KEY_UNSPECIFIED";
    case BuiltinSigningKey.BUILTIN_SIGNING_KEY_ETHEREUM:
      return "BUILTIN_SIGNING_KEY_ETHEREUM";
    case BuiltinSigningKey.BUILTIN_SIGNING_KEY_SERVICE_RESPONSE:
      return "BUILTIN_SIGNING_KEY_SERVICE_RESPONSE";
    case BuiltinSigningKey.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** / Hash function to use for ECDSA message signing. */
export enum HashFunction {
  /** HASH_FUNCTION_UNSPECIFIED - Reserve 0 to detect unset values. */
  HASH_FUNCTION_UNSPECIFIED = 0,
  /** HASH_FUNCTION_SHA256 - Commonly used (e.g. Bitcoin). */
  HASH_FUNCTION_SHA256 = 1,
  /** HASH_FUNCTION_KECCAK256 - Used by Ethereum (original Keccak, not SHA3). */
  HASH_FUNCTION_KECCAK256 = 2,
  /** HASH_FUNCTION_SHA3_256 - NIST standardized versions of Keccak. */
  HASH_FUNCTION_SHA3_256 = 5,
  UNRECOGNIZED = -1,
}

export function hashFunctionFromJSON(object: any): HashFunction {
  switch (object) {
    case 0:
    case "HASH_FUNCTION_UNSPECIFIED":
      return HashFunction.HASH_FUNCTION_UNSPECIFIED;
    case 1:
    case "HASH_FUNCTION_SHA256":
      return HashFunction.HASH_FUNCTION_SHA256;
    case 2:
    case "HASH_FUNCTION_KECCAK256":
      return HashFunction.HASH_FUNCTION_KECCAK256;
    case 5:
    case "HASH_FUNCTION_SHA3_256":
      return HashFunction.HASH_FUNCTION_SHA3_256;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HashFunction.UNRECOGNIZED;
  }
}

export function hashFunctionToJSON(object: HashFunction): string {
  switch (object) {
    case HashFunction.HASH_FUNCTION_UNSPECIFIED:
      return "HASH_FUNCTION_UNSPECIFIED";
    case HashFunction.HASH_FUNCTION_SHA256:
      return "HASH_FUNCTION_SHA256";
    case HashFunction.HASH_FUNCTION_KECCAK256:
      return "HASH_FUNCTION_KECCAK256";
    case HashFunction.HASH_FUNCTION_SHA3_256:
      return "HASH_FUNCTION_SHA3_256";
    case HashFunction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** / Full details of an ECDSA signature, including recovery information. */
export interface EcdsaSignature {
  /**
   * / The 'r' component of this signature;
   * / the 'x' coordinate in the ECDSA signing process.
   * / Always exactly 32 bytes (big-endian).
   */
  r: Buffer;
  /** / The 's' component of this signature. Always exactly 32 bytes (big-endian). */
  s: Buffer;
  /**
   * / One additional bit of information is needed to recover the public key from a
   * / signature in Ethereum, viz., information about whether the affine y coordinate
   * / of the group element is odd.
   * /
   * / The 'v' component of an Ethereum transaction is either
   * / `chain_id * 2 + 35 + is_y_odd` or `27 + is_y_odd`
   * / depending on whether six or nine components are RLP encoded and hashed.
   * /
   * / See https://eips.ethereum.org/EIPS/eip-155 for details.
   */
  isYOdd: boolean;
  /** / Additional information for public key recovery. Not used by Ethereum. */
  isXReduced: boolean;
}

/** / Key selection for signing methods. */
export interface SigningKey {
  /**
   * / The semantics of some values are specified in `BuiltinSigningKey` -
   * / in particular, zero has the special meaning of unspecified/default.
   * /
   * / Values outside the range defined in this enum are application specific.
   * /
   * / The maximum allowed value depends on the configuration. Note that
   * / if the server is configured to support N secret keys, these are
   * / accessed using key_index 1..N.
   */
  keyIndex: number;
}

/** / Sign a 32 byte message digest. */
export interface SignDigestRequest {
  /** / Default key: `SIGNING_KEY_SERVICE_RESPONSE` (used if left as `SIGNING_KEY_UNSPECIFIED`). */
  signingKey:
    | SigningKey
    | undefined;
  /**
   * / The actual digest bytes to sign. Must be exactly 32 bytes.
   * /
   * / When signing an Ethereum transaction or message,
   * / this should be the hash of the transaction or message, as per the Ethereum
   * / specification.
   */
  digest: Buffer;
}

export interface SignDigestResponse {
  signature: EcdsaSignature | undefined;
}

/** / Compute a signature on a message. */
export interface SignMessageRequest {
  /** / Default key: `SIGNING_KEY_SERVICE_RESPONSE` (used if left as `SIGNING_KEY_UNSPECIFIED`). */
  signingKey:
    | SigningKey
    | undefined;
  /** / Hash function to use to compute the digest to sign. */
  hashFunction: HashFunction;
  /** / The bytes of the message to sign. Maximum message size is 1Mib (2**20). */
  message: Buffer;
}

export interface SignMessageResponse {
  /**
   * / An signatuer using Ethereum's 65 byte format `r || s || v`, where `r` and `s`
   * / the signature components (each 32 bytes) and `v` is a zero or one byte
   * / used for key recovery.
   */
  signature: Buffer;
}

export interface SignEthereumTransactionRequest {
  /** / Default key: `SIGNING_KEY_ETHEREUM` (used if left as `SIGNING_KEY_UNSPECIFIED`). */
  signingKey:
    | SigningKey
    | undefined;
  /**
   * / RLP-encoded unsigned transaction.
   * / Must contain 6 or 9 element. If 9 elements are used, the 7th element
   * / it is assumed to be the chain ID and the transaction is signed using EIP-155;
   * / otherwise a legacy signature is used.
   */
  txData: Buffer;
}

export interface SignEthereumTransactionResponse {
  /**
   * / RLP-encoded signed transaction.
   * / Always 9 elements: the six elements from the input, followed by v, r, s.
   */
  txData: Buffer;
}

export interface GetEthereumAddressRequest {
  /** / Default key: `SIGNING_KEY_ETHEREUM` (used if left as `SIGNING_KEY_UNSPECIFIED`). */
  signingKey: SigningKey | undefined;
}

/** TODO: should use 0x prefix? should support ERC-55? */
export interface GetEthereumAddressResponse {
  /** / Hex encoded 40 bytes. */
  ethereumAddress: string;
}

function createBaseEcdsaSignature(): EcdsaSignature {
  return { r: Buffer.alloc(0), s: Buffer.alloc(0), isYOdd: false, isXReduced: false };
}

export const EcdsaSignature: MessageFns<EcdsaSignature> = {
  encode(message: EcdsaSignature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.r.length !== 0) {
      writer.uint32(10).bytes(message.r);
    }
    if (message.s.length !== 0) {
      writer.uint32(18).bytes(message.s);
    }
    if (message.isYOdd !== false) {
      writer.uint32(24).bool(message.isYOdd);
    }
    if (message.isXReduced !== false) {
      writer.uint32(32).bool(message.isXReduced);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EcdsaSignature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEcdsaSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.r = Buffer.from(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.s = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isYOdd = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isXReduced = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EcdsaSignature {
    return {
      r: isSet(object.r) ? Buffer.from(bytesFromBase64(object.r)) : Buffer.alloc(0),
      s: isSet(object.s) ? Buffer.from(bytesFromBase64(object.s)) : Buffer.alloc(0),
      isYOdd: isSet(object.isYOdd) ? globalThis.Boolean(object.isYOdd) : false,
      isXReduced: isSet(object.isXReduced) ? globalThis.Boolean(object.isXReduced) : false,
    };
  },

  toJSON(message: EcdsaSignature): unknown {
    const obj: any = {};
    if (message.r.length !== 0) {
      obj.r = base64FromBytes(message.r);
    }
    if (message.s.length !== 0) {
      obj.s = base64FromBytes(message.s);
    }
    if (message.isYOdd !== false) {
      obj.isYOdd = message.isYOdd;
    }
    if (message.isXReduced !== false) {
      obj.isXReduced = message.isXReduced;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EcdsaSignature>, I>>(base?: I): EcdsaSignature {
    return EcdsaSignature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EcdsaSignature>, I>>(object: I): EcdsaSignature {
    const message = createBaseEcdsaSignature();
    message.r = object.r ?? Buffer.alloc(0);
    message.s = object.s ?? Buffer.alloc(0);
    message.isYOdd = object.isYOdd ?? false;
    message.isXReduced = object.isXReduced ?? false;
    return message;
  },
};

function createBaseSigningKey(): SigningKey {
  return { keyIndex: 0 };
}

export const SigningKey: MessageFns<SigningKey> = {
  encode(message: SigningKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyIndex !== 0) {
      writer.uint32(8).uint32(message.keyIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyIndex = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningKey {
    return { keyIndex: isSet(object.keyIndex) ? globalThis.Number(object.keyIndex) : 0 };
  },

  toJSON(message: SigningKey): unknown {
    const obj: any = {};
    if (message.keyIndex !== 0) {
      obj.keyIndex = Math.round(message.keyIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SigningKey>, I>>(base?: I): SigningKey {
    return SigningKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SigningKey>, I>>(object: I): SigningKey {
    const message = createBaseSigningKey();
    message.keyIndex = object.keyIndex ?? 0;
    return message;
  },
};

function createBaseSignDigestRequest(): SignDigestRequest {
  return { signingKey: undefined, digest: Buffer.alloc(0) };
}

export const SignDigestRequest: MessageFns<SignDigestRequest> = {
  encode(message: SignDigestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingKey !== undefined) {
      SigningKey.encode(message.signingKey, writer.uint32(10).fork()).join();
    }
    if (message.digest.length !== 0) {
      writer.uint32(18).bytes(message.digest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignDigestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignDigestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingKey = SigningKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.digest = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignDigestRequest {
    return {
      signingKey: isSet(object.signingKey) ? SigningKey.fromJSON(object.signingKey) : undefined,
      digest: isSet(object.digest) ? Buffer.from(bytesFromBase64(object.digest)) : Buffer.alloc(0),
    };
  },

  toJSON(message: SignDigestRequest): unknown {
    const obj: any = {};
    if (message.signingKey !== undefined) {
      obj.signingKey = SigningKey.toJSON(message.signingKey);
    }
    if (message.digest.length !== 0) {
      obj.digest = base64FromBytes(message.digest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignDigestRequest>, I>>(base?: I): SignDigestRequest {
    return SignDigestRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignDigestRequest>, I>>(object: I): SignDigestRequest {
    const message = createBaseSignDigestRequest();
    message.signingKey = (object.signingKey !== undefined && object.signingKey !== null)
      ? SigningKey.fromPartial(object.signingKey)
      : undefined;
    message.digest = object.digest ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseSignDigestResponse(): SignDigestResponse {
  return { signature: undefined };
}

export const SignDigestResponse: MessageFns<SignDigestResponse> = {
  encode(message: SignDigestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature !== undefined) {
      EcdsaSignature.encode(message.signature, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignDigestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignDigestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = EcdsaSignature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignDigestResponse {
    return { signature: isSet(object.signature) ? EcdsaSignature.fromJSON(object.signature) : undefined };
  },

  toJSON(message: SignDigestResponse): unknown {
    const obj: any = {};
    if (message.signature !== undefined) {
      obj.signature = EcdsaSignature.toJSON(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignDigestResponse>, I>>(base?: I): SignDigestResponse {
    return SignDigestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignDigestResponse>, I>>(object: I): SignDigestResponse {
    const message = createBaseSignDigestResponse();
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? EcdsaSignature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseSignMessageRequest(): SignMessageRequest {
  return { signingKey: undefined, hashFunction: 0, message: Buffer.alloc(0) };
}

export const SignMessageRequest: MessageFns<SignMessageRequest> = {
  encode(message: SignMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingKey !== undefined) {
      SigningKey.encode(message.signingKey, writer.uint32(10).fork()).join();
    }
    if (message.hashFunction !== 0) {
      writer.uint32(16).int32(message.hashFunction);
    }
    if (message.message.length !== 0) {
      writer.uint32(26).bytes(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingKey = SigningKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hashFunction = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignMessageRequest {
    return {
      signingKey: isSet(object.signingKey) ? SigningKey.fromJSON(object.signingKey) : undefined,
      hashFunction: isSet(object.hashFunction) ? hashFunctionFromJSON(object.hashFunction) : 0,
      message: isSet(object.message) ? Buffer.from(bytesFromBase64(object.message)) : Buffer.alloc(0),
    };
  },

  toJSON(message: SignMessageRequest): unknown {
    const obj: any = {};
    if (message.signingKey !== undefined) {
      obj.signingKey = SigningKey.toJSON(message.signingKey);
    }
    if (message.hashFunction !== 0) {
      obj.hashFunction = hashFunctionToJSON(message.hashFunction);
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignMessageRequest>, I>>(base?: I): SignMessageRequest {
    return SignMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignMessageRequest>, I>>(object: I): SignMessageRequest {
    const message = createBaseSignMessageRequest();
    message.signingKey = (object.signingKey !== undefined && object.signingKey !== null)
      ? SigningKey.fromPartial(object.signingKey)
      : undefined;
    message.hashFunction = object.hashFunction ?? 0;
    message.message = object.message ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseSignMessageResponse(): SignMessageResponse {
  return { signature: Buffer.alloc(0) };
}

export const SignMessageResponse: MessageFns<SignMessageResponse> = {
  encode(message: SignMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignMessageResponse {
    return { signature: isSet(object.signature) ? Buffer.from(bytesFromBase64(object.signature)) : Buffer.alloc(0) };
  },

  toJSON(message: SignMessageResponse): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignMessageResponse>, I>>(base?: I): SignMessageResponse {
    return SignMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignMessageResponse>, I>>(object: I): SignMessageResponse {
    const message = createBaseSignMessageResponse();
    message.signature = object.signature ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseSignEthereumTransactionRequest(): SignEthereumTransactionRequest {
  return { signingKey: undefined, txData: Buffer.alloc(0) };
}

export const SignEthereumTransactionRequest: MessageFns<SignEthereumTransactionRequest> = {
  encode(message: SignEthereumTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingKey !== undefined) {
      SigningKey.encode(message.signingKey, writer.uint32(10).fork()).join();
    }
    if (message.txData.length !== 0) {
      writer.uint32(18).bytes(message.txData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignEthereumTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignEthereumTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingKey = SigningKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txData = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignEthereumTransactionRequest {
    return {
      signingKey: isSet(object.signingKey) ? SigningKey.fromJSON(object.signingKey) : undefined,
      txData: isSet(object.txData) ? Buffer.from(bytesFromBase64(object.txData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: SignEthereumTransactionRequest): unknown {
    const obj: any = {};
    if (message.signingKey !== undefined) {
      obj.signingKey = SigningKey.toJSON(message.signingKey);
    }
    if (message.txData.length !== 0) {
      obj.txData = base64FromBytes(message.txData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignEthereumTransactionRequest>, I>>(base?: I): SignEthereumTransactionRequest {
    return SignEthereumTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignEthereumTransactionRequest>, I>>(
    object: I,
  ): SignEthereumTransactionRequest {
    const message = createBaseSignEthereumTransactionRequest();
    message.signingKey = (object.signingKey !== undefined && object.signingKey !== null)
      ? SigningKey.fromPartial(object.signingKey)
      : undefined;
    message.txData = object.txData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseSignEthereumTransactionResponse(): SignEthereumTransactionResponse {
  return { txData: Buffer.alloc(0) };
}

export const SignEthereumTransactionResponse: MessageFns<SignEthereumTransactionResponse> = {
  encode(message: SignEthereumTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txData.length !== 0) {
      writer.uint32(10).bytes(message.txData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignEthereumTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignEthereumTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txData = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignEthereumTransactionResponse {
    return { txData: isSet(object.txData) ? Buffer.from(bytesFromBase64(object.txData)) : Buffer.alloc(0) };
  },

  toJSON(message: SignEthereumTransactionResponse): unknown {
    const obj: any = {};
    if (message.txData.length !== 0) {
      obj.txData = base64FromBytes(message.txData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignEthereumTransactionResponse>, I>>(base?: I): SignEthereumTransactionResponse {
    return SignEthereumTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignEthereumTransactionResponse>, I>>(
    object: I,
  ): SignEthereumTransactionResponse {
    const message = createBaseSignEthereumTransactionResponse();
    message.txData = object.txData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseGetEthereumAddressRequest(): GetEthereumAddressRequest {
  return { signingKey: undefined };
}

export const GetEthereumAddressRequest: MessageFns<GetEthereumAddressRequest> = {
  encode(message: GetEthereumAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingKey !== undefined) {
      SigningKey.encode(message.signingKey, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEthereumAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEthereumAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingKey = SigningKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEthereumAddressRequest {
    return { signingKey: isSet(object.signingKey) ? SigningKey.fromJSON(object.signingKey) : undefined };
  },

  toJSON(message: GetEthereumAddressRequest): unknown {
    const obj: any = {};
    if (message.signingKey !== undefined) {
      obj.signingKey = SigningKey.toJSON(message.signingKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEthereumAddressRequest>, I>>(base?: I): GetEthereumAddressRequest {
    return GetEthereumAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEthereumAddressRequest>, I>>(object: I): GetEthereumAddressRequest {
    const message = createBaseGetEthereumAddressRequest();
    message.signingKey = (object.signingKey !== undefined && object.signingKey !== null)
      ? SigningKey.fromPartial(object.signingKey)
      : undefined;
    return message;
  },
};

function createBaseGetEthereumAddressResponse(): GetEthereumAddressResponse {
  return { ethereumAddress: "" };
}

export const GetEthereumAddressResponse: MessageFns<GetEthereumAddressResponse> = {
  encode(message: GetEthereumAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ethereumAddress !== "") {
      writer.uint32(10).string(message.ethereumAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEthereumAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEthereumAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ethereumAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEthereumAddressResponse {
    return { ethereumAddress: isSet(object.ethereumAddress) ? globalThis.String(object.ethereumAddress) : "" };
  },

  toJSON(message: GetEthereumAddressResponse): unknown {
    const obj: any = {};
    if (message.ethereumAddress !== "") {
      obj.ethereumAddress = message.ethereumAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEthereumAddressResponse>, I>>(base?: I): GetEthereumAddressResponse {
    return GetEthereumAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEthereumAddressResponse>, I>>(object: I): GetEthereumAddressResponse {
    const message = createBaseGetEthereumAddressResponse();
    message.ethereumAddress = object.ethereumAddress ?? "";
    return message;
  },
};

/** / RPCs provided by the key pool. */
export type KeyPoolServiceService = typeof KeyPoolServiceService;
export const KeyPoolServiceService = {
  signDigest: {
    path: "/key_pool.KeyPoolService/SignDigest",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignDigestRequest) => Buffer.from(SignDigestRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SignDigestRequest.decode(value),
    responseSerialize: (value: SignDigestResponse) => Buffer.from(SignDigestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SignDigestResponse.decode(value),
  },
  signMessage: {
    path: "/key_pool.KeyPoolService/SignMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignMessageRequest) => Buffer.from(SignMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SignMessageRequest.decode(value),
    responseSerialize: (value: SignMessageResponse) => Buffer.from(SignMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SignMessageResponse.decode(value),
  },
  signEthereumTransaction: {
    path: "/key_pool.KeyPoolService/SignEthereumTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignEthereumTransactionRequest) =>
      Buffer.from(SignEthereumTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SignEthereumTransactionRequest.decode(value),
    responseSerialize: (value: SignEthereumTransactionResponse) =>
      Buffer.from(SignEthereumTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SignEthereumTransactionResponse.decode(value),
  },
  getEthereumAddress: {
    path: "/key_pool.KeyPoolService/GetEthereumAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEthereumAddressRequest) =>
      Buffer.from(GetEthereumAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetEthereumAddressRequest.decode(value),
    responseSerialize: (value: GetEthereumAddressResponse) =>
      Buffer.from(GetEthereumAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetEthereumAddressResponse.decode(value),
  },
} as const;

export interface KeyPoolServiceServer extends UntypedServiceImplementation {
  signDigest: handleUnaryCall<SignDigestRequest, SignDigestResponse>;
  signMessage: handleUnaryCall<SignMessageRequest, SignMessageResponse>;
  signEthereumTransaction: handleUnaryCall<SignEthereumTransactionRequest, SignEthereumTransactionResponse>;
  getEthereumAddress: handleUnaryCall<GetEthereumAddressRequest, GetEthereumAddressResponse>;
}

export interface KeyPoolServiceClient extends Client {
  signDigest(
    request: SignDigestRequest,
    callback: (error: ServiceError | null, response: SignDigestResponse) => void,
  ): ClientUnaryCall;
  signDigest(
    request: SignDigestRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignDigestResponse) => void,
  ): ClientUnaryCall;
  signDigest(
    request: SignDigestRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignDigestResponse) => void,
  ): ClientUnaryCall;
  signMessage(
    request: SignMessageRequest,
    callback: (error: ServiceError | null, response: SignMessageResponse) => void,
  ): ClientUnaryCall;
  signMessage(
    request: SignMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignMessageResponse) => void,
  ): ClientUnaryCall;
  signMessage(
    request: SignMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignMessageResponse) => void,
  ): ClientUnaryCall;
  signEthereumTransaction(
    request: SignEthereumTransactionRequest,
    callback: (error: ServiceError | null, response: SignEthereumTransactionResponse) => void,
  ): ClientUnaryCall;
  signEthereumTransaction(
    request: SignEthereumTransactionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignEthereumTransactionResponse) => void,
  ): ClientUnaryCall;
  signEthereumTransaction(
    request: SignEthereumTransactionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignEthereumTransactionResponse) => void,
  ): ClientUnaryCall;
  getEthereumAddress(
    request: GetEthereumAddressRequest,
    callback: (error: ServiceError | null, response: GetEthereumAddressResponse) => void,
  ): ClientUnaryCall;
  getEthereumAddress(
    request: GetEthereumAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetEthereumAddressResponse) => void,
  ): ClientUnaryCall;
  getEthereumAddress(
    request: GetEthereumAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetEthereumAddressResponse) => void,
  ): ClientUnaryCall;
}

export const KeyPoolServiceClient = makeGenericClientConstructor(
  KeyPoolServiceService,
  "key_pool.KeyPoolService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): KeyPoolServiceClient;
  service: typeof KeyPoolServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
