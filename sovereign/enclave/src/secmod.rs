//! This module defines the `Secmod` trait which abstracts away the details
//! of interacting with security modules, such as AWS NSM.

use anyhow::{bail, Result};
use serde_bytes::ByteBuf;

/// Abstract trait representing an attestation document from a security module
/// implementation. This trait is intended to be implemented by some datatype
/// that represents a parsed and validated attestation document.
pub trait AttestationDocument: Send + Sync {
    /// Typically supplied by the entity that has requested this attestation documet.
    fn nonce(&self) -> Option<&ByteBuf>;
    /// If used, typically a public key supplied the the entity that has requested this attestation document.
    fn public_key(&self) -> Option<&ByteBuf>;
    /// May be used for any extra data the the entity that has requested this attestation document wishes to include.
    fn user_data(&self) -> Option<&ByteBuf>;

    /// Return a string that represents the measurement of the code running inside the enclave.
    ///
    /// For AWS, this is the string `AWS-CODE:{PCR-0}:{PCR-1}:{PCR-2}`,
    /// where the PCR measurements are hex-encoded, as in the output of
    /// `nitro-cli build-enclave`.
    fn code_measurement(&self) -> String;

    /// Return a string that represents the measurement of the instance on which this enclave runs.
    ///
    /// For AWS, this is the string `AWS-INSTANCE:{PCR-4}` where `{PCR-4}`
    /// is the hex-encoded value of PCR-4 from the attestation document.
    #[allow(dead_code)]
    // TODO: Use this method...
    fn instance_measurement(&self) -> String;
}

/// This trait represents a security module that aa sovereign interacts with
/// for generating cryptographically signed attestations and related operations.
pub trait Secmod {
    /// The type of attestation documents generated by this security module.
    type Att: AttestationDocument;
    /// The type of socket listeners that this sovereign uses. For example `VSOCK` for AWS Nitro and `TCP` for TDX.
    type Listener: Send;
    /// The type of socket streams that this sovereign uses. See also `Listener`.
    type Stream: tokio::io::AsyncRead + tokio::io::AsyncWrite + Unpin + Send;
    /// A datatype that represents a connection to the security module.
    /// For example, for NSM, this is a file descriptor.
    type Attestor: Send + Sync + Copy;

    /// Start listening to the specified port.
    fn listen(
        port: u32,
    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<Self::Listener>> + Send>>;

    /// Connect to the host in which this enclave runs on the specified port.
    fn connect(
        port: u32,
    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<Self::Stream>> + Send>>;

    /// Accept a connection on the specified listener.
    fn accept(
        listener: &Self::Listener,
    ) -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<Self::Stream>> + Send + '_>>;

    fn measure_code(code: String) -> String;

    fn measure_debug_code() -> String;

    /// This method is intended to be used in conjunction with the `instance_measurement`
    /// of an attestation document.
    ///
    /// ```
    /// let doc = Self::new_attestation(None, None, None)?;
    /// let actual_instance_measurement = doc.instance_measurement();
    /// let expected_instance_measurement = Self::measure_instance(my_instance_id);
    /// assert_eq!(actual_instance_measurement, expected_instance_measurement);
    /// ```
    fn measure_instance(instance: String) -> String;

    /// Create a new attestor for this security module.
    fn init_attestor() -> Result<Self::Attestor>;

    /// Create a new signed attestation document from the security module
    /// containing the specified values for `nonce`,
    /// `public_key`, and `user_data`.
    fn new_attestation(
        attestor: &Self::Attestor,
        nonce: Option<ByteBuf>,
        public_key: Option<ByteBuf>,
        user_data: Option<ByteBuf>,
    ) -> Result<Vec<u8>>;

    /// Parse and validate the signature on a signed attestation document,
    /// as returned from `new_attestation`.
    ///
    /// Note: for secure enclaves, this method must also verify the signature of the attestation document.
    fn parse(doc: &[u8]) -> Result<Self::Att>;

    fn measure_enclave(attestor: &Self::Attestor, data: Vec<Vec<u8>>) -> Result<()>;
}

pub trait AttestationDocumentExt: AttestationDocument {
    fn verify(
        &self,
        expected_nonce: Option<&ByteBuf>,
        expected_public_key: Option<&ByteBuf>,
        expected_user_data: Option<&ByteBuf>,
    ) -> Result<()> {
        if let Some(expected) = expected_nonce {
            match self.nonce() {
                Some(actual) if actual == expected => {
                    tracing::debug!("nonce ok");
                }
                _ => bail!("nonce mismatch"),
            }
        }
        if let Some(expected) = expected_public_key {
            match self.public_key() {
                Some(actual) if actual == expected => {
                    tracing::debug!("public_key ok");
                }
                _ => bail!("public key mismatch"),
            }
        }
        if let Some(expected) = expected_user_data {
            match self.user_data() {
                Some(actual) if actual == expected => {
                    tracing::debug!("user_data ok");
                }
                _ => bail!("user data mismatch"),
            }
        }
        Ok(())
    }
}

impl<T: AttestationDocument> AttestationDocumentExt for T {}
